---
title:设备树规范v0.2
tags: Linux内核
---

------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：本文翻译自<font color=blue>[设备树官网](https://www.devicetree.org/)。</font><font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------

<style>table{word-break:initial;}</style>

**版权**
版权所有2008,2011 Power.org，Inc。
版权所有2008,2011 Freescale Semiconductor，Inc。
版权所有2008,2011 International Business Machines Corporation。
版权所有2016,2017 Linaro，Ltd。
版权所有2016,2017 Arm，Ltd。

Linaro和devicetree.org文字标记以及Linaro和devicetree.org徽标及相关标记是Linaro Ltd.许可的商标和服务标记。本文档某些元素的实施可能需要第三方知识产权获得许可，包括但不限于专利权。 Linaro及其会员不以任何方式对识别或未能识别的任何或所有第三方知识产权负责。

Power Architecture和Power.org文字标记以及Power和Power.org徽标及相关标记是Power.org许可的商标和服务标记。 本文档某些元素的实施可能需要第三方知识产权获得许可，包括但不限于专利权。Power.org及其会员不以任何方式对识别或未能识别的任何或所有第三方知识产权负责。

本规范“按原样”提供，不作任何形式的保证，包括但不限于任何非侵权，适销性或适用于特定用途的表述或暗示性保证。 在任何情况下，linaro或任何linaro成员均不对任何直接，间接，特殊，示范，惩罚或性损性后果害承担责任，包括但不限于利润损失，即使被告知可能发生此类损害。


与本文件或其条款或条件有关的问题应提交至：
Linaro, Ltd
Harston Mill,
Royston Road,
Harston CB22 7GG
Attn: Devicetree.org Board Secretary


**许可证信息**

根据Apache许可证2.0版获得许可;除非符合许可，否则您不得使用此文件。您可以在<http://www.apache.org/licenses/LICENSE-2.0>获取许可证的副本

除非适用的法律要求书面同意，否则，该许可证下的软件分发按“原样”分发，不附带任何明示或暗示的保证或条件。有关该许可证下的特定语言许可和权限，请参阅许可证。

**致谢**
devicetree.org技术指导委员会要感谢许多做出贡献的个人和公司，他们通过写作，技术讨论和评论来对本规范的制定做出了贡献。

我们要感谢开发和发布ePAPR的power.org平台架构技术小组委员会。ePAPR被用作本文件的起点。

Devicetree规范的重要概念基于Open Firmware Working Group所做的工作，该工作组开发了IEEE-1275的绑定。 我们要感谢他们的贡献。

我们还要感谢开发和实现扁平设备树概念的PowerPC和ARM Linux社区的贡献。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;表1 版本历史
|版本|时间|描述|
|:--|:--|:--|
|0.1|2016-05-24|最初的预发布版本。导入ePAPR到结构文本格式，溢出 Power ISA 特定元素。
|0.2|2017-12-20|增加更多推荐的通用节点名<br />增加了中断扩展<br />额外的phy times<br />填写源语言章节中的详细信息<br />编辑变化<br />添加了更改栏版本到发布文档

# 1 介绍
# 1.1 目的和范围

为了初始化和引导计算机系统，各种软件组件进行交互。在将控制权交给软件（如操作系统，引导加载程序或管理程序（hypervisor））之前，固件可能会执行系统硬件的低级初始化。反过来，引导加载程序和管理程序可以加载和转移控制到操作系统。标准，一致的接口和约定有助于这些软件组件之间的交互。在该文档中，术语引导程序一般地指初始化系统状态并执行称为客户端程序的另一软件组件的软件组件。引导程序的示例包括：固件，引导加载程序和管理程序。客户端程序的示例包括：引导加载程序，管理程序，操作系统和专用程序。一个软件可以既是客户端程序又是引导程序（例如，管理程序）。

设备树规范（DTSpec）为客户端程序接口定义提供了完整的引导程序，系统要求最低，这有助于各种系统开发。该规范是针对嵌入式系统。 嵌入式系统通常由系统硬件，操作系统和应用软件组成，这些软件是定制设计用于执行固定的特定任务集。 这与通用计算机不同，通用计算机为具有各种软件和I / O设备的用户设计。 嵌入式系统的其他特性可能包括：

*  一组固定的I / O设备，可能是针对应用程序高度定制的
*  针对尺寸和成本进行优化的系统板
*  有限的用户接口
*  资源限制，如有限的内存和有限的非易失性存储
*  实时约束
*  使用各种操作系统，包括Linux，实时操作系统以及自定义或专有操作系统

**本文件的组织**

*  第1章介绍了DTSpec指定的体系结构。
*  第2章介绍了devicetree概念并描述了其逻辑结构和标准属性。
*  第3章指定了DTSpec兼容设备所需的基本设备节点集的定义。
*  第4章介绍了某类设备和特定设备类型的设备绑定。
*  第5章指定了设备的DTB编码。
*  第6章指定DTS源语言。

**本文档中使用的约定**
“shall”用于表示严格遵守的强制性要求，以符合标准和不允许偏差（shall等于要求）。

“should”一词用于表示在几种可能性中，有一个特别适合因而被推荐，不提及或排除其他可能性; 或者某种行动方案是首选但不一定是必需的; 或者（以否定的形式）某种行为被弃用但不被禁止（should等于推荐）。

“may”一词用于表示在标准范围内允许的动作（may等于允许）。

设备树构造的示例经常以Devicetree Syntax形式显示。 有关此语法的概述，请参见第6节。

## 1.2 与IEEE1275^TM^和ePAPR的关系
DTSpec与IEEE 1275 Open Firmware标准松散相关（松散相关是紧密相关的反义词）。IEEE1275标准是引导（初始化配置）固件的标准：核心要求和实践[^IEEE1275]。

[^IEEE1275]:Boot (Initialization Configuration) Firmware: Core Requirements and Practices, 1994, This is the core standard (also known as IEEE 1275) that defines the devicetree concept adopted by the DTSpec and ePAPR. It is available from Global Engineering (http://global.ihs.com/).

最初的IEEE 1275规范及其衍生产品如CHRP [^CHRP]和PAPR [^PAPR]解决了通用计算机的问题，例如单个版本的操作系统如何在同一系列中的几台不同计算机上工作以及从用户安装的I / O设备加载操作系统。

[^CHRP]: PowerPC Microprocessor Common Hardware Reference Platform (CHRP) Binding, Version 1.8, Open Firmware Working Group, 1998(http://playground.sun.com/1275/bindings/chrp/chrp1_8a.ps). This document specifies the properties for Open PIC-compatible interrupt controllers.

[^PAPR]: Power.org Standard for Power Architecture Platform Requirements, power.org

由于嵌入式系统的性质，开放式通用计算机所面临的一些问题不会发生。 DTSpec中省略的IEEE 1275规范的显著特征包括：

* 插件设备驱动程序
* FCode
* 基于Forth的可编程Open Firmware用户界面
* FCode调试
* 操作系统调试
 
 从IEEE 1275保留的是来自设备树架构的概念，通过该概念，引导程序可以描述并将系统硬件信息传送到客户端程序，从而消除了客户端程序具有系统硬件的硬编码（hard-code）描述的需要。
 
该规范部分取代了ePAPR [^EPAPR]规范。 ePAPR记录了Power ISA如何使用设备树，并涵盖了一般概念以及Power ISA特定绑定。 本文档的文本源自ePAPR，但要么删除特定于体系结构的绑定，要么将它们移动到附录中。


[^EPAPR]:Power.org Standard for Embedded Power Architecture Platform Requirements, power.org, 2011, https://www.power.org/documentation/power-org-standard-for-embedded-power-architecture-platform-requirements-epapr-v1-1-2/

## 1.3 32位和64位支持
DTSpec支持具有32位和64位寻址功能的CPU。 在适用的情况下，DTSpec的各个部分描述了32位和64位寻址的任何要求或注意事项。

## 1.4 术语定义
**AMP** 非对称多处理。计算机可用的CPU被分区为组，每个组运行不同的操作系统映像。 CPU可能（may）相同也可能不相同。

**引导CPU（boot CPU）** 引导程序指向客户端程序入口点的第一个CPU。

**Book III-E** 嵌入式环境。 Power ISA的一部分，定义了嵌入式Power处理器实现中使用的监控指令和相关设施。

**引导程序（boot program）** 通常指初始化系统状态并执行另一个软件组件的软件组件。引导程序的示例包括：固件，引导加载程序和管理程序。

**客户程序（client program）**  典型的客户程序包含应用程序或操作系统软件。客户端程序的示例包括：引导加载程序，管理程序，操作系统和专用程序。

**cell** 32位信息单元。

**DMA** 直接内存访问。

**DTB** devicetree blob。设备树的二进制形式。

**DTC** 设备树编译器，用于从DTS文件创建DTB文件的一个开源工具。

**DTS** Devicetree syntax。设备树的文本表示。参见附录A 设备树源文件格式（版本1）

**有效地址（effective addres）**  由处理器存储访问或分支指令计算的内存地址。


**物理地址（physical address）** 处理器用于访问外部设备的地址，典型如：内存控制器。

**Power ISA** Power 指令集架构。

**中断说明符（interrupt specifier）**  描述中断的属性值。 典型地，包扩中断号、灵敏度、触发机制。

**次级CPU（secondary CPU ）** 除引导CPU之外的属于客户程序的CPU。

**SMP** 对称多处理。 一种计算机体系结构，其中两个或多个相同的CPU可以共享内存 和IO并在单个操作系统下运行。

**SoC** 片上系统。 单个计算机芯片集成了一个或多个CPU核心以及许多其他外围设备。

**单元地址（unit address）**  节点名的一部分，指定节点在父节点的地址空间中的地址。

**静态CPU（quiescent CPU）** 静态CPU是一种状态，它不会干扰其他CPU正常操作，也不会被其它正在运行的CPU的正常操作影响，除非用显式方法 启用或重新启用静态CPU，

# 2 设备树
## 2.1 概述
DTSpec指定一种设备树的构造来描述系统硬件。引导程序将设备加载到客户程序的内存中，并将指向设备树的指针传递给客户程序。

本章描述了设备树的逻辑结构，并指定了一组用于描述设备树节点的基本属性集。第3章要求符合DTSpec规范的的设备树需要的某些设备节点。第6章描述了DSpec定义的设备绑定 ——表示某些设备类型或类别的要求。 第8章描述了设备树的内存中编码。

设备树是具有描述系统中的设备的节点的数据结构。每个节点都有属性/值对，用于描述所表示设备的特征。 每个节点只有一个父节点，但根节点除外，它没有父节点。

符合设备树规范的设备树描述在系统中客户端程序不一定能动态检测到的设备信息。例如，PCI的体系结构使客户程序能够测试和检测连接的设备，因此可能不需要描述PCI设备的设备树节点。但是，如果无法探测和检测到则需要设备节点来描述系统中的PCI主桥设备。

**示例**
图2.1显示了一个简单设备树的示例表示，该设备树几乎完全足以启动简单的操作系统，具有平台类型、CPU、内存和单个UART。 每个节点内都有属性和值。

![1](https://www.github.com/liao20081228/blog/raw/master/图片/设备树规范v0.2/1.JPG)

## 2.2 设备树结构和约定
### 2.2.1 节点名称
**节点名称要求**

设备树中的每个节点都根据以下约定命名：

&emsp;node-name@unit-address

node-name指定节点的名称。 它的长度应为（shall）1到31个字符，仅由表2.1中的字符集中的字符组成。

 ![3](https://www.github.com/liao20081228/blog/raw/master/图片/设备树规范v0.2/3.JPG)
 
node-name必须（shall）以小写或大写字符开头，并应（should）描述设备的通用类别。
 
unit-address特指节点所在的总线类型。它由表2.1中的一个或多个ASCII字符组成。unit-address必须与节点的reg属性中指定的第一个地址匹配。 如果节点没有reg属性，则必须省略@unit-address，并且node-name单独将节点与树中同一级别的其他节点区分开来。 特定总线的绑定可能（may）对reg和unit-address的格式指定更多，更具体的要求。

根节点没有node-name或unit-address。 它由正斜杠（/）标识。

![4](https://www.github.com/liao20081228/blog/raw/master/图片/设备树规范v0.2/4.JPG)

在图2.2中：

* 名称为cpu的节点按其单元地址值0和1进行区分。
* 名称为ethernet的节点通过其单元地址值Fe002000和Fe003000进行区分。

### 2.2.2 通用名称建议
节点的名称应该（should）是通用的，反映了设备的功能而不是其精确的编程模型。 如果合适，名称应该（should）是以下选项之一：

* adc
* accelerometer
* atm
* audio-codec
* audio-controller
* backlight
* bluetooth
* bus
* cache-controller
* camera
* can
* charger
* clock
* clock-controller
* compact-flash
* can
* cpu
* cpus
* crypto
* disk
* display
* dma-controller
* dsp
* eeprom
* efuse
* endpoint
* ethernet
* ethernet-phy
* fdc
* flash
* gpio
* gpu
* gyrometer
* hdmi
* i2c
* ide
* interrupt-controller
* isa
* keyboard
* key
* keys
* lcd-controller
* led
* leds
* led-controller
* light-sensor
* magnetometer
* mailbox
* mdio
* memory
* memory-controller
* mmc
* mmc-slot
* mouse
* nand-controller
* nvram
* oscillator
* parallel
* pc-card
* pci
* pcie
* phy
* pinctrl
* pmic
* pmu
* port
* ports
* pwm
* regulator
* reset-controller
* rtc
* sata
* scsi
* serial
* sound
* spi
* sram-controller
* ssi-controller
* syscon
* temperature-sensor
* timer
* touchscreen
* usb
* usb-hub
* usb-phy
* video-codec
* vme
* watchdog
* wifi
###  2.2.3 路径名称
通过指定从根节点经过所有后代节点到目标节点的完整路径，可以唯一地识别设备树中的节点。

指定设备路径的约定是：

&emsp;/node-name-1/node-name-2/node-name-N

例如，在图2.2中，cpu＃1的设备路径为：

&emsp;/cpus/cpu@1

根节点的路径是/。

如果节点的完整路径是明确的，则可以省略单元地址。

如果客户程序遇到不明确的路径，则其行为未定义。

### 2.2.4 属性
设备树中的每个节点都具有描述节点特征的属性。 属性由名称和值组成。

**属性名称**

属性名称是由表2.2中的字符组成的长度为1到31的字符串。

![5](https://www.github.com/liao20081228/blog/raw/master/图片/设备树规范v0.2/5.JPG)

非标准属性名称应指定唯一的字符串前缀，例如股票代码，标识定义属性的公司或组织的名称。例子：

&emsp;&emsp;fsl,channel-fifo-len
&emsp;&emsp;ibm,ppc-interrupt-server#s
&emsp;&emsp;linux,network-index**

**属性值**’
属性值是零个或多个字节的数组，其中包含与属性关联的信息。

如果为真假信息，则属性可能（may）为空值。 在这种情况下，该属性是否存就足够描述了。

表2.3描述了DTSpec定义的基本值类型。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;表2.3 属性值
|值|描述|
|:--|:--|
|\<empty\>|值为空。 属性本身是否存在就足以用于传达真假信息。
|\<u32\>|大端模式的32位整数。 例如:  0x11223344 在内存表示为:<br />&emsp;&emsp;&emsp;address 11<br />&emsp;&emsp;address+1 22<br />&emsp;&emsp;address+2 33<br />&emsp;&emsp;address+3 44
|\<64\>|大端模式的64位整数。 由两个u32值组成，其中第一个值包含高有效位，第二个值包含低有效位。示例：64位值0x1122334455667788将表示为两个单元格：\<0x11223344 0x55667788\>。该值将在内存中表示为：<br />&emsp;&emsp;&emsp;address 11<br />&emsp;&emsp;address+1 22<br />&emsp;&emsp;address+2 33<br />&emsp;&emsp;address+3 44<br />&emsp;&emsp;address+4 55<br />&emsp;&emsp;address+5 66<br />&emsp;&emsp;address+6 77<br />&emsp;&emsp;address+7 88<br />&emsp;&emsp;
|\<string\>|字符串可打印，并且以null结尾。 示例：字符串“hello”将在内存中表示为：<br />&emsp;&emsp;&emsp;address 68 'h'<br />&emsp;&emsp;address+1 65 'e'<br />&emsp;&emsp;address+2 6C 'l'<br />&emsp;&emsp;address+3 6C 'l'<br />&emsp;&emsp;address+4 6F 'o'<br />&emsp;&emsp;address+5 00 '\0'
|\<prop-encoded-array>|特定属性格式 。 请参阅属性定义。|
|\<phandle\>|一个u32值。 一个phandle值是在设备树中引用另一个节点的一种方法。可以引用的任何节点都定了具有唯一的u32值的phandle属性。该数字用于具有phandle值类型的属性的值。
|\<stringlist> |字符串列表。例如:字符串列表 “hello”,”world” 将在内存中表示为:<br />&emsp;&emsp;&emsp;address 68 'h'<br />&emsp;&emsp;address+1 65 'e'<br />&emsp;&emsp;address+2 6C 'l'<br />&emsp;&emsp;address+3 6C 'l'<br />&emsp;&emsp;address+4 6F 'o'<br />&emsp;&emsp;address+5 00 '\0'<br />&emsp;&emsp;address+6 77 'w'<br />&emsp;&emsp;address+7 6f 'o'<br />&emsp;&emsp;address+8 72 'r'<br />&emsp;&emsp;address+9 6C 'l'<br />&emsp;&emsp;address+10 64 'd'<br />&emsp;&emsp;address+11 00 '\0'<br />&emsp;&emsp;


















------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：本文翻译自<font color=blue>[设备树官网](https://www.devicetree.org/)。</font><font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------
