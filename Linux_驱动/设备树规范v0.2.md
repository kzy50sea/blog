---
title: 设备树规范v0.2
tags: Linux内核
---

------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：本文翻译自<font color=blue>[设备树官网](https://www.devicetree.org/)。</font><font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------

<style>table{word-break:initial;}</style>



# 5 扁平设备树（DTB）格式

设备树Blob（DTB）格式是设备树数据的平面二进制编码。 它用于在软件程序之间交换设备树数据。 例如，在引导操作系统时，固件会将DTB传递给OS内核。

>注意：IEEE1275开放固件[IEEE1275]未定义DTB格式。 在大多数符合Open Firmware的平台上，通过调用固件方法来提取设备树以遍历树结构。


DTB格式在单个线性无指针数据结构内对设备树数据进行编码。 它由一个header（见5.2节）和三个可变大小的部分组成：memory reservation block（见5.3节），structure block（见第5.4节）和strings block（见5.5节）。 这些应按顺序存在于扁平设备树中。 因此，当按地址处加载到内存中时，整个设备树结构将类似于图5.1中的图（较低地址位于图的顶部）。

![8](https://www.github.com/liao20081228/blog/raw/master/图片/设备树规范v0.2/8.JPG)

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图5.1 设备树.dtb结构

free space 部分可能不存在，但在某些情况下，它们可能需要满足各个块的对齐约束（参见第5.6节）。


## 5.1 版本控制
自DTB格式的原始定义以来，已经定义了几种版本的扁平设备树结构。 header中的字段给出版本，以便客户程序可以确定设备树是否以兼容格式编码。

本文档仅描述DTB格式的第17版。 符合DTSpec的引导程序应提供版本17或更高版本的设备树，并应提供与版本16向后兼容的版本的设备树。符合DTSpec标准的客户端程序应接受与版本17向后兼容的任何版本的设备树，并且也可以接受其他版本。

注意：版本是关于设备树的二进制结构，而不是其内容。

## 5.2 header
设备树的header布局由以下C结构定义。 所有头字段都是32位整数，以大端格式存储。

```c
struct fdt_header {
	uint32_t magic;
	uint32_t totalsize;
	uint32_t off_dt_struct;
	uint32_t off_dt_strings;
	uint32_t off_mem_rsvmap;
	uint32_t version;
	uint32_t last_comp_version;
	uint32_t boot_cpuid_phys;
	uint32_t size_dt_strings;
	uint32_t size_dt_struct;
};
```
**magic** 该字段应包含值0xd00dfeed（大端模式）。

**totalsize** 该字段必须包含设备树数据结构的总大小（以字节为单位）。 该大小应包含结构的所有部分：头部，内存保留块，结构块和字符串块，以及块之间或最终块之后的任何空闲内存区。

**off_dt_struct** 该字段必须包含从头部的起始位置开始计算的结构块的偏移量（参见5.4节）。

**off_dt_strings** 该字段必须包含从头部的起始位置开始计算的字符串块的偏移量（参见5.5节）。

**off_mem_rsvmap** 该字段必须包含从头部的起始位置开始计算的内存保留块的偏移量（参见5.3节）

**version** 该字段必须包含设备树数据结构的版本。 如果使用本文档中定义的结构，则版本为17。 DTSpec引导程序可以提供更高版本的设备树，在这种情况下，该字段应包含在后面的文档中定义的版本号，该文档给出该版本的详细信息。

**last_comp_version** 该字段必须包含当前设备树数据结构可以兼容的最低版本。 因此，对于本文档（版本17）中定义的结构，此字段应包含16，因为版本17兼容版本16，但不兼容早期版本。 根据5.1节，DTSpec引导程序应提供与版本16兼容的格式的设备树，因此该字段应始终包含16。

**boot_cpuid_phys**  该字段必须包含系统引导CPU的物理ID。 它应与设备树中该CPU节点的reg属性中给出的物理ID相同。

**size_dt_strings** 该字段应包含设备树的字符串块部分的字节长度。

**size_dt_struct**  该字段应包含设备树的结构块部分的字节长度。



## 5.3 内存保留块
### 5.3.1 目的

内存保留块为客户程序提供了一个保留的物理内存的列表; 也就是说，它不能用于一般的内存分配。它用于保护重要数据结构不被客户程序覆盖。例如，在某些具有IOMMU的系统上，需要以这种方式保护由DTSpec引导程序初始化的TCE（转换控制条目）表。同样，需要保留在客户端程序运行时期间使用的任何引导程序代码或数据（例如，Open Firmware平台上的RTAS）。DTSpec不要求引导程序提供任何此类运行时组件，但它不禁作为扩展实现。


更具体地说，客户端程序不应访问保留区域中的内存，除非引导程序提供的其他信息明确指示它应该这样做。然后，客户程序可以以指示的方式访问保留内存的指示部分。引导程序向客户机程序指示预留内存的特定用途的方法可以出现本文档、可选的扩展或特定于平台的文档中。

>原文为：More specifically, a client program shall not access memory in a reserved region unless other information provided by the boot program explicitly indicates that it shall do so. The client program may then access the indicated section of the reserved memory in the indicated manner. Methods by which the boot program can indicate to the client program specific uses for reserved memory may appear in this document, in optional extensions to it, or in platform-specific documentation.

由引导程序提供的保留区域可以但不是必须包含设备树二进制本身。 客户程序应确保在使用之前不会覆盖此数据结构，无论它是否在保留区域内。

在内存节点中声明并由引导程序访问或在客户程序进入后由引导程序访问的任何内存都必须保留。 这种类型的访问的示例包括（例如，通过非保护虚拟页面的推测性内存读取）。

此要求是必要的，因为具有任意存储属性的客户程序可以访问未保留的任何内存。


引导程序对保留内存的访问或由引导程序造成的对保留内存的访问必须被完成，就像没有缓存禁止和内存一致性要求一样，另外对于Book III-S实现，就像没有Write Through要求（即WIMG = 0b001x）。此外，如果支持VLE存储属性，则必须以VLE = 0完成对保留存储器的所有访问。
>原文为： Any accesses to reserved memory by or caused by the boot program must be done as not Caching Inhibited and Memory Coherence Required (i.e., WIMG = 0bx01x), and additionally for Book III-S implementations as not Write Through Required (i.e., WIMG = 0b001x). 

 此要求是必要的，因为允许客户端程序映射内存，其存储属性指定为没有Write Through要求，没有缓存禁止和内存一致性要求（即WIMG = 0b001x），并且支持VLE = 0。客户程序可以使用包含保留内存的大型虚拟页面，但是，客户端程序可能不会修改保留的内存，因此引导程序可以执行对保留内存的访问，如同Write Through Required一样，其中此存储属性的冲突值在架构上是允许的。
  
 >原文为：This requirement is necessary because the client program is permitted to map memory with storage attributes specified as not Write Through Required, not Caching Inhibited, and Memory Coherence Required (i.e., WIMG = 0b001x), and VLE=0 where supported. The client program may use large virtual pages that contain reserved memory. However, the client program may not modify reserved memory, so the boot program may perform accesses to reserved memory as Write Through Required where conflicting values for this storage attribute are architecturally permissible.
  
 ### 5.3.2 格式
 
 内存保留块由64位大端整数的对（pair）列表组成，每对由下面的C结构表示。
 ```c
struct fdt_reserve_entry {
	uint64_t address;
	uint64_t size;
};
 ```
每对（pair）给出保留内存区域的物理地址和大小（以字节为单位）。 这些给定区域不应相互重叠。 保留块列表应以地址和大小均等于0的条目终止。请注意，地址和大小值始终为64位。 在32位CPU上，忽略该值的高32位。

内存保留块中的每个uint64_t以及整个内存保留块应位于距设备树二进制开头的8字节对齐的偏移处（参见5.6节）。

## 5.4 结构块
结构块描述了设备树本身的结构和内容。 它由如下所述的一系列带有数据的标记组成。 它们被组织成线性树结构，如下所述。

结构块中的每个标记，以及结构块本身，应位于距设备树二进制开头的4字节对齐的偏移处（见5.6）。

### 5.4.1 词汇结构

结构块由一系列片段组成，每个片段以标记开头，它是一个大端的32位整数。一些标记后面跟着额外的数据，其格式由标记值决定。 所有标记都应在32位边界上对齐，这可能需要在前一个标记的数据之后插入填充字节（值为0x0）。 五种令牌类型如下：

**FDT_BEGIN_NODE (0x00000001)** FDT_BEGIN_NODE表示节点的开始。它后面必须（shall）是节点的单元名称作为额外数据。该名称存储为以空字符结尾的字符串，并且应包括单元地址（请参阅第2.2.1节）（如果有）。如果需要进行对齐，则节点名称后跟填充的零填充字节，然后是下一个标记，可以是除FDT_END之外的任何标记。

**FDT_END_NODE (0x00000002)** FDT_END_NODE表示节点的结束。 此标记没有额外数据; 所以紧接着是下一个家伙，可以是除FDT_PROP之外的任何标记。

**FDT_PROP (0x00000003)** FDT_PROP表示设备树中一个属性的开始。 随后必须（shall）有描述该属性的额外数据。 此数据首先包含属性的长度和名称，表示为以下C结构：
```c
struct {
	uint32_t len;
	uint32_t nameoff;
}
```
这个结构中的两个字段都是32位大端整数。
* len 给出了属性值的长度（以字节为单位）（可以为零，表示空属性，请参见第2.2.4.2节）。
* nameoff 给出了在字符串块中的偏移量（参见第5.5节），在字符串块中，属性的名称存储为以空字符结尾的字符串。

在此结构之后，属性的值以长度为len的字符串给出。 该值之后是零填充字节（如果需要）以对齐到下一个32位边界，然后是下一个标记，可以是除FDT_END之外的任何标记。

**FDT_NOP (0x00000004)** FDT_NOP将被解析设备树的任何程序忽略。此标记没有额外数据; 所以紧接着是下一个标记，它可以是任何有效的标记。可以使用FDT_NOP覆盖树中定义的属性或节点，以将其从设备树中移除，而无需在设备树二进制中移动设备树的表示的其他部分。

**FDT_END (0x00000009)** FDT_END标记结构块的结尾。一个设备树中只有一个FDT_END标记，它应该是结构块中的最后一个标记。 它没有额外的数据; 所以紧接在FDT_END标记之后；所以从结构块的开头算起的紧接在FDT_END标记之后的字节的偏移量等于设备树二进制的头中的size_dt_struct字段的值。

### 5.4.2 树结构
设备树结构表示为线性树：每个节点的表示以FDT_BEGIN_NODE标记开始，以FDT_END_NODE标记结束。 节点的属性和子节点（如果有）在FDT_END_NODE之前表示，以至于这些子节点的FDT_BEGIN_NODE和FDT_END_NODE标记嵌套在父节点的FDT_BEGIN_NODE和FDT_END_NODE标记中。

整个结构块由根节点的表示（包含所有其他节点的表示）和 后跟一个标记结构块结束的FDT_END标记组成。

更确切地说，每个节点的表示由以下组件组成：

* (可选)任意数量的FDT_NOP标记
* FDT_BEGIN_NODE 标记
	*  节点的名称：以null结尾的字符串
	*   [零填充字节以对齐4字节边界]
* 对于节点的每个属性：
	* (可选)任意数量的FDT_NOP标记
	* FDT_PROP标记
		* 5.4.1节中给出的属性信息
		* [零填充字节以对齐4字节边界]
* 以此格式表示所有子节点
* (可选)任意数量的FDT_NOP标记
* FDT_END_NODE令牌

请注意，此过程要求特定节点的所有属性定义都在该节点的任何子节点定义之前。 虽然如果属性和子节点混合在一起，结构也不会模糊，但是这个要求简化了处理扁平树所需的代码。

## 5.5 字符串块

字符串块包含设备树中使用的所有属性名称的字符串。 这些以空终止的字符串在本块中简单地连接在一起，并结构块中的偏移进行引用。

字符串块没有对齐约束，可能出现在距设备树二进制开头的任何偏移处。

## 5.6 对齐

对于没有未对齐内存访问的内存保留和结构块中的数据，它们应该位于适当对齐的内存地址。具体地说，内存保留块必须与8字节边界对齐，结构块必须与4字节边界对齐。

此外，可以重定位设备树二进制而不破坏子块的对齐。

如前面部分所述，结构和字符串块应与设备树二进制的开头具有对齐的偏移量。
为了确保块的内存中对齐，足以确保整个设备树被加载到与任何子块的最大对齐对齐的地址，即8字节边界。

为了确保内存中块的对齐，整个设备树加载到与所有子块中的最大对齐字节边界对齐的地址，即8字节边界就足够了。符合DTSpec标准的引导程序应在将设备树blob传递给客户端程序之前将其加载到这样的对齐地址。 如果DTSpec客户程序将设备树二进制重新定位到内存中，则它应该只对另一个8字节对齐的地址执行此操作。













------

&emsp;&emsp;<font color=blue>**_版权声明_**</font>：本文翻译自<font color=blue>[设备树官网](https://www.devicetree.org/)。</font><font color=red>未经作者允许，<font color=blue>严禁用于商业出版</font>，否则追究法律责任。网络转载请注明出处，这是对原创者的起码的尊重！！！</font>

------
66675468